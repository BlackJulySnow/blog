title: 第二届“计协杯”程序设计大赛暨ACM实验室招新选拔4月赛题解
mathjax: true
date: 2022-06-06 13:28:00
tags:
---
# [第二届“计协杯”程序设计大赛暨ACM实验室招新选拔4月赛](/contest.php?cid=1049)
>  “计协杯”是由湖南工程学院计算机协会举办的程序设计竞赛，旨在提高同学们激发学生学习计算机领域专业知识与技能的兴趣，鼓励主动灵活地运用计算机知识和技能解决实际问题，有效提升算法设计、逻辑推理、数学建模、编程实现和计算机系统能力，培养团队合作意识、挑战精神和创新能力。

# A：买苹果
> #### 题目描述
> LM 是一个有钱的素数狂热爱好者，有一天来到一个苹果摊上看到有 n 个苹果，他想挑选重量为素数的苹果，这可难到他了，你能帮帮他吗
>#### 输入格式
>第一行 一个数字 n,
第二行 n 个数字 w1  w2  w3  ...  wn  其中 wi 代表第 i 个苹果的重量。
> #### 输出格式
> 输出一个数 LM 买的所有素数苹果的总重量。

这道题目其实就是一道比较简单的求素数的问题，求素数有两种方法，一种暴力求素数，一种筛法求素数，对于时间复杂度而言，筛法求素数比暴力求素数更加快，而这道题其实不要用到筛法求素数，只需要在暴力求素数的方法上加以改进一下就可以过了。
### 记得求和的时候用上long long，否则得到的总数会撑爆int，也就是超出int的数据范围从而得到负数的情况。

```c
#include"stdio.h"
#include"math.h"
int a[100010];
int main() {
    int n,j;
    long long sum = 0;
    scanf("%d",&n);
    for(int i = 0;i < n;i ++)
        scanf("%d",&a[i]);
    for(int i = 0;i < n;i ++){
        for(j = 2;j <= sqrt(a[i]); j ++){
            if(a[i] % j == 0)break;
        }
        if(sqrt(a[i]) < j){
            sum += a[i];
        }
    }
    printf("%lld",sum);
    return 0;
}
```


# B：买西瓜
> #### 题目描述
> 今天，zj 和他的朋友买了一个西瓜，他们想要把西瓜分成两份。
>作为数学迷，他们两个人都喜欢偶数，但是他们不知道这个西瓜能不能分成两个偶数重量的西瓜，
>请你帮一帮他们判断买的西瓜能不能分成两个偶数重量的西瓜。
> #### 输入格式
> 输入一行包含整数 w ( 1 ≤  w  ≤ 100 )代表男孩们买的西瓜的重量。
> #### 输出格式
> 如果可以将西瓜分成两部分，每部分重偶数公斤则输出YES；
>如果不能分成两份偶数重量的西瓜则为NO。注：输出都为大写字符

通过分析题目可以快速发现，若西瓜的重量为偶数的话 是必定可以分成两个偶数重量的西瓜的，但是，有一个特殊情况需要排除，这也是本题的唯一坑点，就是当w = 2 时，虽然它也是一个偶数，但是它并不可以分出两个偶数重量的部分。了解这些后就可以开始编写程序了。


```c
#include "stdio.h"

int main() {
    int w;
    scanf("%d",&w);
    if(w%2 == 0 && w!=2)
        printf("YES\n");
    else
        printf("NO\n");

    return 0;
}
```
# C：比赛
> #### 题目描述
>今天学校举办了一场足球比赛，一天一共有 n 场比赛，这次比赛总共有 6 支球队参加，赢一场积 3 分，平一场积 1 分，输则积 0 分。
>现在我们来写一个简单的程序，根据一个小组所有比赛的结果，输出各队的积分。
>若没有参赛则视为弃权，按 0 分输出。
> #### 输入格式
> 第一行一个整数n，表示有n场比赛。
>将参赛的 6 个队伍编号为  A ~ F  6个字母， 每行为空格隔开的两个大写字母与两个整数，表示两支队伍比赛对应的进球数，
>A B 1 2表示AB的比赛比分为A 1 : B 2。
> #### 输出格式
> 输出一行 6 个整数分别是A~F的积分。

通过分析题目可知一共有6个球队，他们之间将进行足球比赛，容易分析出每场比赛只有三种情况，胜负和平局。
我们可以设置一个一维数组用来记录每支球队的分数，用几个临时的变量来存储当前比赛队伍及其得分情况。
这里建议使用字符串输入队伍编号，避免出现输入错误的问题。不要忘记在使用score数组前对其进行初始化。


```c
#include "stdio.h"

int main() {
int n;
int score[7];
char team1[2],team2[2];
int shot1, shot2;

    scanf("%d",&n);

    for(int i=0; i<7; i++)
        score[i] = 0;
    for(int i=0; i<n; i++){
        scanf("%s%s%d%d",team1,team2,&shot1,&shot2);
        if(shot1 < shot2)
            score[team2[0] - 'A' + 1] += 3;
        else if(shot1 == shot2){
            score[team1[0] - 'A' + 1] += 1;
            score[team2[0] - 'A' + 1] += 1;
        }
        else{
            score[team1[0] - 'A' + 1] += 3;
        }

    }

    for(int i=1; i<=6; i++)
        printf("%d ",score[i]);

    return 0;
}

```


# D：WA学长的小女友
> #### 题目描述
> WA 学长有一个漂亮可爱的女朋友，但是他的女朋友脾气很怪异，看到一些特殊的字符就会发脾气，
今天，WA 找女朋友有点事需要发微信，WA 为了不让他的女朋友发脾气，
他希望可以将一条信息里所有让他女朋友生气的字符全部删除再发微信给他女朋友。
> #### 输入格式
> 第一行需要发送的信息。
第二行一个字符串代表需要删除的字符 。
> #### 输出格式
> 输出一行处理过的信息。

对于这道题目,如果按照惯性思维来写，肯定是对两个字符串进行遍历，如果有就进行删除等操作，但是这个题目的字符串的数据量很大，所以这个方法行不通。
那我们应该用什么方法来解决这个问题呢，每一个字母都有对应的ASCII码，而这个ASCII码就是我们解决这道题目的关键。
我们可以先对需要删除的字符进行打表，确认它需要删除，然后再对原字符串的元素进行判断是否含有这些字符在进行删除。
### 记得输入的时候一定要用gets函数，而不是scanf("%s",a),这样子当字符串有空格时读入会不完整。

```c
#include<stdio.h>
char a[100010],b[100010];
int st[310];

int main ()
{
    gets(a);
    gets(b);
    for (int i = 0;i < sizeof(b);i ++) { //特殊的循环方式
        st[b[i]] = 1;
    }
    for (int i = 0; i < sizeof(a); i ++ ) {
        if (!st[a[i]])
            printf ("%c", a[i]);
    }
    return 0;
}
```

# E：扔葡萄皮
> #### 题目描述
> 今天，ZJ 吃了很多的葡萄，但是剩下的葡萄皮怎么处理呢？
刚开始吃葡萄时，他将葡萄皮随意的放在了桌子上，一共有 n 堆，
但是他作为一个强迫症，他想不改动原有的葡萄皮让每个堆的葡萄皮数量均不相同。
现在有一个操作，ZJ 可以再吃一个葡萄并将葡萄皮扔在任意一个堆上。他想让这个操作数最少，因为他实在吃不下更多的葡萄了，请你帮一帮他。
> #### 输入格式
> 第一行包含一个整数 n；
第二行包含 n 个数 a1,a2,...,an;
> #### 输出格式
>一个整数，表示所需的最少操作次数。

这道题目就考察的是一个贪心的算法，这类算法顾名思义就是要够贪才能AC，如果你不够贪就会错。
那么对于这道题目我们应该怎么贪心，题目中说要让每一个葡萄皮堆的葡萄皮数量不相同，而且要
操作数最少，那么我么们就可以对于测试样例进行一次模拟，发现只要对于一个1进行操作就可以达到
题目的要求，如此我们可以知道，当得到一些葡萄皮堆，我们可以先对他们进行排序，从第二堆葡萄皮堆到
最后一个葡萄皮堆，每个葡萄皮堆比前面的葡萄皮堆多1个，这样子我们就可以得到这个题目最优解。
### 记得sum要long long哦

```c
#include<stdio.h>
int a[10010];
int main()
{
    int n ;
    scanf("%d",&n);
    for(int i = 0;i < n;i ++){
        scanf("%d",&a[i]);
    }
    for(int i = 0;i < n - 1;i ++){//控制比较轮次，一共 n-1 趟
        for(int j = 0;j < n - 1 - i;j ++){//控制两个挨着的元素进行比较
            if(a[j] > a[j + 1]){
                int t = a[j];
                a[j] = a[j+1];
                a[j+1] = t;
            }
        }
    }
    long long sum = 0;
    for(int i = 1;i < n;i ++){
        if(a[i] <= a[i - 1]){
            sum += a[i - 1] - a[i] + 1;
            a[i] = a[i - 1] + 1;
        }
    }
    printf("%lld",sum);
}
```

# F：买南瓜
> #### 题目描述
>tyy 买了 n 个南瓜，他有 n 个孩子，每个孩子的年龄都不相同，现在 tyy 的孩子们排成一列，
>他希望将南瓜按他们年龄大小分给他们，即年龄大的孩子分到的南瓜比年龄小的孩子分到的南瓜大。
> #### 输入格式
> 第一行一个数字 n 代表南瓜（孩子）的数量。
>第二行 n 个数字 a1 a2 a3 ... an 其中 ai 代表孩子的年龄。
>第三行 n 个数字 b1 b2 b3 ... bn 其中 bi 代表南瓜的重量。
> #### 输出格式
> 输出对应孩子所得的南瓜重量。

### 思路分析
这道题目要按照输入的孩子年龄为序列输出，所以一般来说孩子序列的顺序还是不要修改的好，所以我们对南瓜序列进行修改。
将南瓜序列进行排序之后，就可以知道南瓜是第几大的，在对每个孩子判断他是第几大的就给第几大的南瓜，这道题目就迎刃而解了。
### C代码
```c
#include<stdio.h>

#define N 10010
int a[2][N], b[N], n;
void Wsort(int a[], int n)  // 冒泡排序
{
    for (int i = 0; i < n - 1; i ++ ) {
        for (int j = 0; j < n - 1 - i; j ++ ) {
            if (a[j + 1] < a[j]) {
                int t = a[j + 1];
                a[j + 1] = a[j];
                a[j] = t;
            } 
        }
    }
}
 
int main()
{
    cin >> n;
    for(int i = 0;i < n;i ++){
        scanf("%d", a[0][i]);
    }
    for(int i = 0;i < n;i ++){
        scanf("%d", b[i]);
    }
    Wsort(b, n);
    for(int i = 0;i < n;i ++){
        int count = 0;
        for(int j = 0;j < n;j ++){
            if(a[0][i] > a[0][j]){
                count ++;
            }
        }
        a[1][i] = b[count];
    }
    for(int i = 0;i < n;i ++)
        printf ("%d ", a[1][i]);
}
```
### C++代码
```c++
#include <iostream>
#include <algorithm>
#include <cstdio>
 
using namespace std;
 
const int N = 1e4 + 10;
 
typedef pair<int, int> PII;
 
int n, b[N], c[N];
PII a[N];
 
bool cmp(PII a, PII b) {
    return a.first < b.first;
}
 
int main ()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) {
        scanf("%d", &a[i].first);
        a[i].second = i;
    }
    for (int i = 0; i < n; i ++ ) {
        scanf("%d", &b[i]);
    }
 
    sort(a, a + n, cmp);
    sort(b, b + n);
 
    for (int i = 0; i < n; i ++ ) {
        c[a[i].second] = b[i];
    }
 
    for (int i = 0; i < n; i ++ ) {
        printf ("%d ", c[i]);
    }
 
    return 0;
}
```


# G：城市最短距离
> #### 题目描述
> 已知现在有n个城市，城市以1到n进行编号，不同城市之间的距离为两城市编号的最大公约数。
> 求城市 x 到城市 y 的所需移动的最短距离。
> #### 输入格式
> 第一行两个数n，q。表示有n个城市，q组询问。
> 接下来q行，每行两个数x，y。
> #### 输出格式
> 每个询问输出一行，每行一个数字表示答案

首先对于每一个城市$i$都有自己编号，而任意的两个城市$(x,y)$都有一个距离$gcd(x,y)$
1. 如果给定的两个$x$和$y$有$x=y$，那么他们之间距离为$0$，可以直接到达。
2. 如果对于任意两个城市$gcd(i,j)=1$,即该两个城市互质，则他们的距离就是$1$
3. 如果对于任意两个城市$(x,y)\not=1$,那么他们之间可以从$x$先到$1$，再从$1$到$y$，因为$gcd(1,AnyNumber)=1$,这样就可以走可以保证两步之内到达。
### 记得使用puts("")，本题的输入输出数据量比较大，如果用printf会超时

```c
#include "stdio.h"

int n,q,x,y;
int gcd(int a,int b){
    return b == 0 ? a : gcd(b,a % b);
}
int main() {
    scanf("%d%d",&n,&q);
    for(int i = 1;i <= q;i++){
        scanf("%d%d",&x,&y);
        if(x == y)
            puts("0");
        else if(gcd(x,y) == 1)
            puts("1");
        else
            puts("2");
    }
    return 0;
}
```

# H：扔香蕉皮
> #### 题目描述
>TYY 是一个非常坏的男孩，但同时，他也十分爱吃香蕉。 于是，他决定用香蕉皮来惹恼他的朋友 ZJ。
>ZJ 的房间可以表示为一个 n 行 m 列的网格。 让 ( i , j ) 表示第 i 行和第 j 列的单元格。 ZJ 目前站在他房间里的位置 ( i , j )。 为了惹恼 ZJ，TYY 决定在房间里扔两个香蕉皮（它们可以在同一个单元格里）。
>因为 ZJ 不喜欢香蕉皮扔在地板上，他必须把他们俩都捡起来，然后回到原来的位置。ZJ 走过的距离是穿过两个香蕉皮的位置并返回 ( i , j ) 的最短路径，走的过程中只能到相邻的单元。也就是说，如果他在房间的位置为( x , y )然后他可以前往房间( x+1 , y ), ( x-1 , y ), ( x , y+1 ), ( x , y-1 )。
>TYY 想知道他应该把这两个香蕉皮扔在哪里，这样 ZJ 走过的距离就会最大化。但是因为他很忙，他让你告诉他。
> #### 输入格式
>第一行包含一个整数 t 代表 t 组测试样例。
>每个测试用例的唯一行包含四个整数 n, m, i, j  代表房间的尺寸，以及 ZJ 目前站立的位置。
> #### 输出格式
> 对于每个测试用例，打印四个整数 x1, y1, x2, y2  代表两个香蕉皮应该扔在哪里的坐标。
>如果有多个答案，你只需要输出任意一种答案。

### 思路分析:
容易验证，将两个悠悠球扔在房间对角线的两个角落，Riley 需要移动的总距离一定最长。

以样例中的第 3 组数据（n=3，m=5，i=2，j=2）为例：

其中蓝色点表示 Riley 的初始位置，两个红色点表示悠悠球的位置，绿色箭头表示 Riley 的一种移动的路线。

当把两个悠悠球分别扔在房间的左上角和右下角时，Riley 移动的路线长度相当于在房间的外围走一圈，此时路线最长：

![upload successful](/blog/images/pasted-0.png)

当把两个悠悠球分别扔在房间的左上角和右上角时，Riley 移动的路线长度显然小于上一种情况：

![upload successful](/blog/images/pasted-1.png)

上述结论成立。

可以发现对于初始位置在房间外围的情况，会有其他的最优解，但此时将悠悠球扔在房间对角线的两个角落亦是一种最优解。

所以，你可以输出以下两种答案中的任意一种：

1、左上角和右下角，即 (1,1) 和 (n,m)；

2、右上角和左下角，即 (1,m) 和 (n,1)。

### 代码

```c
#include <stdio.h>
int t, n, m, i, j;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d%d%d",&n,&m,&i,&j);
		printf("%d %d %d %d\n",1,1,n,m);
	}
	return 0;
}
```


# I：斐波那契数列
>#### 题目描述
>这是一道 “简单” 的求斐波那契数列题目。
>Fn = Fn-1 + Fn-2
>求出 Fn 的值，答案可能过大，需要将输出的答案对 1000000007 取余。
>#### 输入格式
>一行一个正整数 n
>#### 输出格式
>输出一行一个整数表示答案。

相信C语言课都讲过递归求斐波那契数列或者循环求斐波那契数列，这道题目可以看到数据范围在2<sup>63</sup>,所以如果用普通的方法只能拿50分，需要另寻他法。
我们令$f(n)$,$f(n-1)$组成一个列向量，乘以一个$2\times2$的矩阵可以得到$f(n+1)$,$f(n)$
$$
  \begin{bmatrix}
  a&b\\
  c&d
\end{bmatrix}
*
\begin{bmatrix}
  f(n)\\f(n-1)
\end{bmatrix}
=
\begin{bmatrix}
  f(n+1)\\f(n)
\end{bmatrix}
$$
又线性代数展开可以得到如下式子
$$
  \begin{bmatrix}
  a&b\\
  c&d
\end{bmatrix}
*
\begin{bmatrix}
  f(n)\\f(n-1)
\end{bmatrix}
=
\begin{bmatrix}
  a*f(n) + b*f(n-1)\\c*f(n)+d*f(n-1)
\end{bmatrix}
$$

并且$f(n+1)=f(n)+f(n-1)$,对应项相等，可以得到
$$
\begin{bmatrix}
  f(n+1)\\f(n)
\end{bmatrix}
=
\begin{bmatrix}
  a*f(n) + b*f(n-1)\\c*f(n)+d*f(n-1)
\end{bmatrix}
$$
即$a=1$  ,  $b=1$  ,  $c=1$  ,  $d=0$
如此由矩阵的乘法可得，由$n$个矩阵乘法相乘，我们令矩阵
$$
  \begin{bmatrix}
  a&b\\
  c&d
\end{bmatrix}
= A
$$
那么需要得到$f(n)$就可以列出如下式子。
$$
\begin{bmatrix}
  1&1\\
  1&0
\end{bmatrix}^{n-1}
* 
\begin{bmatrix}
  f(1)\\f(0)
\end{bmatrix}
=
\begin{bmatrix}
  f(n)\\f(n-1)
\end{bmatrix}
$$
然后使用矩阵快速幂即可快速算出答案。
```c
#include "stdio.h"
#include "cstring"
#define ll long long
#define MOD 1000000007
ll n;
ll base[2][2] = {{0,1},{1,1}};
ll f[2] = {0,1};
void multi(ll a[2],ll b[2][2]){
    ll ans[2] = {0,0};
    for(int i = 0; i < 2; i++)
        for(int j = 0; j < 2; j++)
            ans[j] = (ans[j] + a[i] * b[i][j]) % MOD;
    memcpy(a,ans,sizeof(ans));
}
void self(ll a[2][2]){
    ll ans[2][2];
    memset(ans,0,sizeof(ans));
    for(int i = 0;i < 2;i++)
        for(int j = 0;j < 2;j++)
            for(int k = 0;k < 2;k++)
                ans[i][j] = (ans[i][j] + a[i][k] * a[k][j]) % MOD;
    memcpy(a,ans,sizeof(ans));
}
int main() {
    scanf("%d",&n);
    while(n){
        if(n & 1)
            multi(f,base);
        self(base);
        n >>= 1;
    }
    printf("%d",f[0]);
    return 0;
}
```